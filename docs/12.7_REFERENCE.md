# Quick Reference

**Part of**: [Python Architecture for Aerospace Reliability](12.0_OVERVIEW.md)

---

## TL;DR

Quick lookup for imports, API signatures, common patterns, and troubleshooting.

---

## I. Import Cheatsheet

### Core Types

```python
from aerospace_reliability.core.types import (
    HealthState,
    FailureType,
    FaultToleranceStrategy,
    CircuitState,
    RecoveryLevel,
    FailureEvent,
    DetectionResult,
    RecoveryResult,
    IsolatedSubsystem,
)
```

### Protocols

```python
from aerospace_reliability.core.protocols import (
    ExecutionContext,
    Agent,
    DetectionStrategy,
    IsolationStrategy,
    RecoveryStrategy,
    VotingStrategy,
    HealthMonitor,
    MetricsCollector,
    CompositionOperator,
)
```

### Exceptions

```python
from aerospace_reliability.core.exceptions import (
    AerospaceReliabilityError,
    DetectionError,
    IsolationError,
    RecoveryError,
    RecoveryExhaustedError,
    CircuitOpenError,
    NoConsensusError,
    SafeModeError,
    ConfigurationError,
    AdapterError,
)
```

### Detection Strategies

```python
from aerospace_reliability.detection import (
    TimeoutDetector,
    TimeoutDetectorConfig,
    ExceptionDetector,
    OutputValidationDetector,
    ValidationDetectorConfig,
    StatisticalAnomalyDetector,
    AnomalyDetectorConfig,
    CompositeDetector,
)
```

### Isolation Strategies

```python
from aerospace_reliability.isolation import (
    CircuitBreakerIsolation,
    CircuitBreakerConfig,
    HierarchicalIsolation,
    HierarchicalIsolationConfig,
    BulkheadIsolation,
    BulkheadConfig,
)
```

### Recovery Strategies

```python
from aerospace_reliability.recovery import (
    RetryStrategy,
    RetryConfig,
    FallbackStrategy,
    FallbackConfig,
    DegradationStrategy,
    DegradationConfig,
    SafeModeStrategy,
    SafeModeConfig,
    EscalationLadder,
)
```

### High-Level Patterns

```python
from aerospace_reliability.patterns import (
    FDIRAgent,
    FDIRAgentConfig,
    TMRAgent,
    TMRAgentConfig,
    RetryAgent,
    RetryAgentConfig,
    FallbackChainAgent,
    FallbackChainConfig,
    HealthMonitorAgent,
    HealthMonitorConfig,
    CircuitBreakerAgent,
    CircuitBreakerAgentConfig,
)
```

### Adapters

```python
from aerospace_reliability.adapters import (
    GenericAdapter,
    GoogleADKAdapter,
    LangChainAdapter,
    OpenAIAdapter,
)
```

### Configuration

```python
from aerospace_reliability.config import (
    FDIRConfig,
    DetectionConfig,
    IsolationConfig,
    RecoveryConfig,
    ConfigLoader,
)
```

---

## II. API Signatures Quick Reference

### Detection

```python
# TimeoutDetector
TimeoutDetector(config: TimeoutDetectorConfig = None)
TimeoutDetectorConfig(timeout_seconds=30.0, warning_threshold=0.8)

# OutputValidationDetector
OutputValidationDetector(config: ValidationDetectorConfig = None)
ValidationDetectorConfig(validator=None, min_length=None, max_length=None, required_fields=None)

# StatisticalAnomalyDetector
StatisticalAnomalyDetector(config: AnomalyDetectorConfig = None)
AnomalyDetectorConfig(zscore_threshold=3.0, window_size=100, min_samples=10)

# CompositeDetector
CompositeDetector(strategies: List[DetectionStrategy], fail_fast: bool = True)
```

### Isolation

```python
# CircuitBreakerIsolation
CircuitBreakerIsolation(config: CircuitBreakerConfig = None)
CircuitBreakerConfig(failure_threshold=5, recovery_timeout=30.0, half_open_max_calls=1)

# BulkheadIsolation
BulkheadIsolation(config: BulkheadConfig = None)
BulkheadConfig(max_concurrent=10, max_queue_size=100, timeout_seconds=30.0)
```

### Recovery

```python
# RetryStrategy
RetryStrategy(config: RetryConfig = None)
RetryConfig(max_retries=3, base_delay=1.0, max_delay=60.0, backoff_factor=2.0, jitter=0.1)

# EscalationLadder
EscalationLadder(strategies: List[RecoveryStrategy])
```

### Patterns

```python
# FDIRAgent
FDIRAgent(agent: Agent, config: FDIRAgentConfig = None)

# TMRAgent
TMRAgent(agents: List[Agent], voting_strategy: VotingStrategy = MajorityVoting())

# HealthMonitorAgent
HealthMonitorAgent(agent: Agent, config: HealthMonitorConfig = None)
HealthMonitorConfig(check_interval=60.0, degraded_threshold=0.8, failed_threshold=0.95)
```

---

## III. Pattern Selection Flowchart

```
START: What's your reliability requirement?
│
├─► Transient failures (API timeouts, rate limits)?
│   └─► RetryAgent or CircuitBreakerAgent
│
├─► Need provider redundancy?
│   └─► FallbackChainAgent
│
├─► Critical decisions requiring consensus?
│   └─► TMRAgent with appropriate voting strategy
│
├─► Continuous health monitoring?
│   └─► HealthMonitorAgent
│
├─► Full fault tolerance (mission-critical)?
│   └─► FDIRAgent (combines all above)
│
└─► Simple wrapper?
    └─► GenericAdapter → any pattern
```

---

## IV. Common Code Patterns

### Pattern 1: Basic FDIR Wrapping

```python
from aerospace_reliability.patterns import FDIRAgent
from aerospace_reliability.adapters import GenericAdapter

# Wrap any async function
agent = GenericAdapter(my_async_func, name="my_agent")
protected = FDIRAgent(agent)

# Use with automatic fault tolerance
async for result in protected.execute(input, context):
    process(result)
```

### Pattern 2: TMR for Critical Decisions

```python
from aerospace_reliability.patterns import TMRAgent
from aerospace_reliability.composition import MajorityVoting

tmr = TMRAgent(
    agents=[agent1, agent2, agent3],
    voting_strategy=MajorityVoting(similarity_threshold=0.9)
)
```

### Pattern 3: Fallback Chain

```python
from aerospace_reliability.patterns import FallbackChainAgent

chain = FallbackChainAgent(
    primary=expensive_agent,
    fallbacks=[cheap_agent, cached_agent]
)
```

### Pattern 4: Custom Detection

```python
from aerospace_reliability.detection import CompositeDetector, TimeoutDetector

detector = CompositeDetector([
    TimeoutDetector(TimeoutDetectorConfig(timeout_seconds=10.0)),
    OutputValidationDetector(ValidationDetectorConfig(
        validator=lambda x: len(x) > 0
    ))
])
```

### Pattern 5: Configuration Loading

```python
from aerospace_reliability.config import ConfigLoader

# Load from multiple sources, merge
config = ConfigLoader.merge(
    ConfigLoader.from_yaml("base_config.yaml"),
    ConfigLoader.from_env("FDIR_")
)
```

---

## V. Troubleshooting Guide

### Problem: CircuitOpenError

**Symptom**: `CircuitOpenError: Circuit breaker open for 'agent'. Recovery in 25.3s`

**Causes**:
1. Too many consecutive failures
2. Recovery timeout not elapsed

**Solutions**:
```python
# Increase failure threshold
CircuitBreakerConfig(failure_threshold=10)  # Default: 5

# Decrease recovery timeout
CircuitBreakerConfig(recovery_timeout=15.0)  # Default: 30.0

# Check underlying agent health
print(agent.health_state)
```

### Problem: RecoveryExhaustedError

**Symptom**: `RecoveryExhaustedError: Recovery exhausted after trying: [L0_RETRY, L1_FALLBACK]`

**Causes**:
1. All retry attempts failed
2. All fallback agents failed
3. Underlying service truly unavailable

**Solutions**:
```python
# Add more recovery strategies
recovery_strategies=[
    RetryStrategy(RetryConfig(max_retries=5)),  # More retries
    FallbackStrategy(fallback_agents=[backup1, backup2, backup3]),
    DegradationStrategy(),  # Graceful degradation
    SafeModeStrategy()  # Last resort
]

# Check if failure type is retryable
RetryConfig(retryable_failures=(FailureType.TIMEOUT, FailureType.RATE_LIMIT))
```

### Problem: NoConsensusError

**Symptom**: `NoConsensusError: No consensus among 3 results`

**Causes**:
1. Agents returning different results
2. Similarity threshold too high
3. Insufficient successful results

**Solutions**:
```python
# Lower similarity threshold
MajorityVoting(similarity_threshold=0.7)  # Default: 0.9

# Add more agents for better consensus
TMRAgent(agents=[a1, a2, a3, a4, a5])  # 5MR instead of TMR

# Use LLM judge for semantic comparison
LLMJudgeVoting(judge_agent, criteria="Select the most accurate response")
```

### Problem: Slow Performance

**Symptom**: High latency after adding FDIR

**Causes**:
1. Expensive detection strategies
2. Too many retry attempts
3. TMR overhead

**Solutions**:
```python
# Use fail_fast detection
CompositeDetector(strategies, fail_fast=True)

# Reduce retry delays
RetryConfig(base_delay=0.5, max_delay=10.0)

# Async health monitoring (doesn't block)
HealthMonitorConfig(check_interval=60.0)  # Background checks
```

---

## VI. Testing Patterns

### Unit Testing Detection Strategies

```python
import pytest
from aerospace_reliability.detection import TimeoutDetector

@pytest.mark.asyncio
async def test_timeout_detector_healthy():
    detector = TimeoutDetector(TimeoutDetectorConfig(timeout_seconds=10.0))
    context = MockContext()

    result = await detector.detect({"elapsed": 5.0}, context)

    assert result.is_healthy
    assert result.confidence > 0.9

@pytest.mark.asyncio
async def test_timeout_detector_failure():
    detector = TimeoutDetector(TimeoutDetectorConfig(timeout_seconds=10.0))
    context = MockContext()

    result = await detector.detect({"elapsed": 15.0}, context)

    assert not result.is_healthy
    assert result.failure_type == FailureType.TIMEOUT
    assert result.severity == 1.0
```

### Integration Testing FDIR Pipeline

```python
import pytest
from aerospace_reliability.patterns import FDIRAgent

@pytest.mark.asyncio
async def test_fdir_recovery():
    # Create agent that fails twice then succeeds
    call_count = 0
    async def flaky_agent(input, context):
        nonlocal call_count
        call_count += 1
        if call_count < 3:
            raise TimeoutError("Temporary failure")
        return f"Success: {input}"

    agent = GenericAdapter(flaky_agent, name="flaky")
    fdir = FDIRAgent(agent, FDIRAgentConfig(
        recovery_strategies=[RetryStrategy(RetryConfig(max_retries=5))]
    ))

    context = MockContext()
    results = []
    async for result in fdir.execute("test", context):
        results.append(result)

    assert len(results) == 1
    assert "Success" in results[0]
    assert call_count == 3
```

### Mocking External LLM Calls

```python
from unittest.mock import AsyncMock, patch

@pytest.mark.asyncio
async def test_tmr_with_mocked_llms():
    mock_responses = ["response_a", "response_a", "response_b"]

    agents = []
    for i, response in enumerate(mock_responses):
        mock_agent = AsyncMock()
        mock_agent.name = f"agent_{i}"
        mock_agent.execute = AsyncMock(return_value=async_iter([response]))
        agents.append(mock_agent)

    tmr = TMRAgent(agents, MajorityVoting())
    context = MockContext()

    results = []
    async for result in tmr.execute("test", context):
        results.append(result)

    assert results[0] == "response_a"  # Majority vote
```

### Property-Based Testing for Composition

```python
from hypothesis import given, strategies as st

@given(st.lists(st.text(), min_size=2, max_size=5))
def test_majority_voting_deterministic(responses):
    """Voting should be deterministic for same inputs."""
    voting = MajorityVoting()

    result1 = voting.vote(responses)
    result2 = voting.vote(responses)

    assert result1 == result2

@given(st.integers(min_value=1, max_value=10))
def test_retry_backoff_increases(max_retries):
    """Backoff delays should increase with attempts."""
    strategy = RetryStrategy(RetryConfig(max_retries=max_retries))

    delays = [strategy._calculate_delay(i) for i in range(max_retries)]

    # Each delay should be >= previous (ignoring jitter variance)
    for i in range(1, len(delays)):
        assert delays[i] >= delays[i-1] * 0.8  # Allow for jitter
```

---

## VII. Dependency Injection Points

| Component | Injection Point | Default | Custom Implementation |
|-----------|----------------|---------|----------------------|
| Detection | `FDIRAgentConfig.detectors` | Timeout + Anomaly | Any `DetectionStrategy` |
| Isolation | `FDIRAgentConfig.isolation_strategy` | CircuitBreaker | Any `IsolationStrategy` |
| Recovery | `FDIRAgentConfig.recovery_strategies` | Retry + Degrade | Any `RecoveryStrategy` |
| Voting | `TMRAgent(voting_strategy=)` | MajorityVoting | Any `VotingStrategy` |
| Metrics | Via plugin registry | In-memory | Prometheus, StatsD |
| Logging | `AuditLogger(logger=)` | stdlib logging | Any logger |

---

## VIII. Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `FDIR_DETECTION__TIMEOUT_SECONDS` | Timeout threshold | 30.0 |
| `FDIR_ISOLATION__FAILURE_THRESHOLD` | Circuit breaker threshold | 5 |
| `FDIR_ISOLATION__RECOVERY_TIMEOUT` | Circuit recovery time | 30.0 |
| `FDIR_RECOVERY__MAX_RETRIES` | Maximum retry attempts | 3 |
| `FDIR_RECOVERY__BASE_DELAY` | Initial retry delay | 1.0 |
| `FDIR_HEALTH_MONITORING` | Enable health checks | true |
| `FDIR_METRICS_ENABLED` | Enable metrics collection | true |

---

## IX. Version Compatibility

| Component | Python | asyncio | Pydantic |
|-----------|--------|---------|----------|
| Core | 3.9+ | Required | 2.0+ |
| Google ADK Adapter | 3.10+ | Required | 2.0+ |
| LangChain Adapter | 3.9+ | Required | 2.0+ |
| OpenAI Adapter | 3.9+ | Required | 2.0+ |

---

## X. Related Documentation

| Document | Content |
|----------|---------|
| [12.0_OVERVIEW.md](12.0_OVERVIEW.md) | Navigation, status, design principles |
| [12.1_CORE_ABSTRACTIONS.md](12.1_CORE_ABSTRACTIONS.md) | Types, protocols, exceptions |
| [12.2_FDIR_STRATEGIES.md](12.2_FDIR_STRATEGIES.md) | Detection, isolation, recovery |
| [12.3_COMPOSITION.md](12.3_COMPOSITION.md) | Operators, algebraic properties |
| [12.4_PATTERNS.md](12.4_PATTERNS.md) | High-level pattern implementations |
| [12.5_INTEGRATION.md](12.5_INTEGRATION.md) | Adapters, config, metrics, security |
| [12.6_EXAMPLES.md](12.6_EXAMPLES.md) | Complete code examples |
| [11_AEROSPACE_RELIABILITY_PATTERNS.md](11_AEROSPACE_RELIABILITY_PATTERNS.md) | Theoretical foundations |
| [10_UNIFIED_THEORY.md](10_UNIFIED_THEORY.md) | 4D design space theory |
